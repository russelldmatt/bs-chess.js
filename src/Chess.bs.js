// Generated by BUCKLESCRIPT VERSION 2.2.3, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Random = require("bs-platform/lib/js/random.js");
var $$String = require("bs-platform/lib/js/string.js");
var ChessJs = require("chess.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Js_option = require("bs-platform/lib/js/js_option.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Js_primitive = require("bs-platform/lib/js/js_primitive.js");
var Js_null_undefined = require("bs-platform/lib/js/js_null_undefined.js");

function ofRaw(raw) {
  switch (raw) {
    case "b" : 
        return /* Black */0;
    case "w" : 
        return /* White */1;
    default:
      return Js_exn.raiseError("Cannot convert color from raw (raw: " + (raw + ")"));
  }
}

function toRaw(t) {
  if (t !== 0) {
    return "w";
  } else {
    return "b";
  }
}

function toString(t) {
  if (t !== 0) {
    return "white";
  } else {
    return "black";
  }
}

function toChar(t) {
  if (t >= 101) {
    if (t >= 103) {
      if (t >= 104) {
        return /* "h" */104;
      } else {
        return /* "g" */103;
      }
    } else if (t >= 102) {
      return /* "f" */102;
    } else {
      return /* "e" */101;
    }
  } else if (t >= 99) {
    if (t >= 100) {
      return /* "d" */100;
    } else {
      return /* "c" */99;
    }
  } else if (t >= 98) {
    return /* "b" */98;
  } else {
    return /* "a" */97;
  }
}

function ofChar(c) {
  var switcher = c - 97 | 0;
  if (switcher > 7 || switcher < 0) {
    return Js_exn.raiseError("Cannot convert File.t from char (char: " + ($$String.make(1, c) + ")"));
  } else {
    return switcher + 97 | 0;
  }
}

function ofString(s) {
  return ofChar(Caml_string.get(s, 0));
}

function toString$1(t) {
  var c = toChar(t);
  return $$String.make(1, c);
}

var all = /* :: */[
  /* a */97,
  /* :: */[
    /* b */98,
    /* :: */[
      /* c */99,
      /* :: */[
        /* d */100,
        /* :: */[
          /* e */101,
          /* :: */[
            /* f */102,
            /* :: */[
              /* g */103,
              /* :: */[
                /* h */104,
                /* [] */0
              ]
            ]
          ]
        ]
      ]
    ]
  ]
];

var File = /* module */[
  /* toChar */toChar,
  /* ofChar */ofChar,
  /* ofString */ofString,
  /* toString */toString$1,
  /* all */all
];

function toString$2(t) {
  var c = toChar(t[/* file */0]);
  return $$String.make(1, c) + String(t[/* rank */1]);
}

function ofString$1(s) {
  return /* record */[
          /* file */ofChar(Caml_string.get(s, 0)),
          /* rank */Caml_format.caml_int_of_string($$String.make(1, Caml_string.get(s, 1)))
        ];
}

var Square = /* module */[
  /* toString */toString$2,
  /* ofString */ofString$1
];

function ofRaw$1(raw) {
  var raw$1 = $$String.lowercase(raw);
  switch (raw$1) {
    case "b" : 
        return /* bishop */-262202819;
    case "k" : 
        return /* king */-955653801;
    case "n" : 
        return /* knight */-470198899;
    case "p" : 
        return /* pawn */-900601784;
    case "q" : 
        return /* queen */-571834454;
    case "r" : 
        return /* rook */-877728231;
    default:
      return Js_exn.raiseError("Cannot convert piece from raw (raw: " + (raw$1 + ")"));
  }
}

function toRaw$1(t) {
  if (t >= -877728231) {
    if (t >= -470198899) {
      if (t >= -262202819) {
        return "b";
      } else {
        return "n";
      }
    } else if (t >= -571834454) {
      return "q";
    } else {
      return "r";
    }
  } else if (t >= -900601784) {
    return "p";
  } else {
    return "k";
  }
}

function toString$3(t) {
  if (t >= -877728231) {
    if (t >= -470198899) {
      if (t >= -262202819) {
        return "bishop";
      } else {
        return "knight";
      }
    } else if (t >= -571834454) {
      return "queen";
    } else {
      return "rook";
    }
  } else if (t >= -900601784) {
    return "pawn";
  } else {
    return "king";
  }
}

function ofRaw$2(raw) {
  return /* record */[
          /* type_ */ofRaw$1(Js_option.getExn(Js_primitive.undefined_to_opt(raw["type"]))),
          /* color */ofRaw(Js_option.getExn(Js_primitive.undefined_to_opt(raw["color"])))
        ];
}

function toString$4(t) {
  return toString(t[/* color */1]) + (" " + toString$3(t[/* type_ */0]));
}

function create(fen, _) {
  var match = typeof (window) === "undefined" ? undefined : (window);
  if (match !== undefined) {
    return new ChessJs(fen ? fen[0] : undefined);
  } else {
    return new ChessJs.Chess(fen ? fen[0] : undefined);
  }
}

function ascii(prim) {
  return prim.ascii();
}

function fen(prim) {
  return prim.fen();
}

function gameOver(prim) {
  return +prim.game_over();
}

function get(t, square) {
  var rawSquare = toString$2(square);
  console.log("raw square: ", rawSquare);
  var raw = t.get(rawSquare);
  return Belt_Option.map((raw == null) ? /* None */0 : [raw], ofRaw$2);
}

function toRaw$2(t) {
  return {
          from: t[/* from */0],
          to: t[/* to_ */1]
        };
}

function ofRaw$3(raw) {
  return /* record */[
          /* color */ofRaw(raw.color),
          /* from */ofString$1(raw.from),
          /* to_ */ofString$1(raw["to"]),
          /* flags */raw.flags,
          /* piece */ofRaw$1(raw.piece),
          /* san */raw.san
        ];
}

function toRaw$3(t) {
  return {
          color: toRaw(t[/* color */0]),
          from: toString$2(t[/* from */1]),
          to: toString$2(t[/* to_ */2]),
          flags: t[/* flags */3],
          piece: toRaw$1(t[/* piece */4]),
          san: t[/* san */5]
        };
}

var Options = /* module */[];

function legalMoves(move_options, t) {
  var square = Belt_Option.flatMap(move_options, (function (x) {
          return x[/* square */0];
        }));
  var raw_full_moves = square ? t.moves({
          square: toString$2(square[0]),
          verbose: /* true */1
        }) : t.moves({
          verbose: /* true */1
        });
  console.log(raw_full_moves);
  return $$Array.map(ofRaw$3, raw_full_moves);
}

function move(t, req) {
  var parseResponse = function (r) {
    return Belt_Option.map((r == null) ? /* None */0 : [r], ofRaw$3);
  };
  switch (req.tag | 0) {
    case 0 : 
        return parseResponse(t.move(req[0]));
    case 1 : 
        return parseResponse(t.move(toRaw$2(req[0])));
    case 2 : 
        return parseResponse(t.move(req[0][/* san */5]));
    
  }
}

function loadPgn(sloppy, t, pgn) {
  var sloppy$1 = Js_null_undefined.fromOption(Belt_Option.map(sloppy, (function (s) {
              return {
                      sloppy: s
                    };
            })));
  return +t.load_pgn(pgn, sloppy$1);
}

var chess = create(/* None */0, /* () */0);

console.log(chess.ascii());

console.log(chess.fen());

var chess$1 = create(/* Some */["6nr/3p2pp/5Q2/3b2B1/1nk1PPBP/p4Np1/p5R1/1R1K1N2 b - - 2 40"], /* () */0);

var full_move = /* record */[
  /* color : Black */0,
  /* from : record */[
    /* file : a */97,
    /* rank */2
  ],
  /* to_ : record */[
    /* file : a */97,
    /* rank */1
  ],
  /* flags */"np",
  /* piece : pawn */-900601784,
  /* san */"a1=B"
];

console.log(chess$1.ascii());

console.log(toRaw$3(full_move));

console.log(Belt_Option.map(move(chess$1, /* Full */Block.__(2, [full_move])), toRaw$3));

console.log(chess$1.ascii());

console.log(chess$1.ascii());

console.log("hey");

console.log(chess$1.ascii());

console.log(+chess$1.game_over());

console.log(get(chess$1, /* record */[
          /* file : e */101,
          /* rank */8
        ]));

console.log(get(chess$1, /* record */[
          /* file : e */101,
          /* rank */1
        ]));

console.log(Belt_Option.map(get(chess$1, /* record */[
              /* file : g */103,
              /* rank */2
            ]), toString$4));

var allRanks = $$Array.to_list($$Array.init(8, (function (x) {
            return x + 1 | 0;
          })));

var allSquares = List.concat(List.map((function (file) {
            return List.map((function (rank) {
                          return /* record */[
                                  /* file */file,
                                  /* rank */rank
                                ];
                        }), allRanks);
          }), all));

console.log("gettin all squares");

var allPieces = Belt_List.keepMap(allSquares, (function (square) {
        return Belt_Option.map(get(chess$1, square), (function (piece) {
                      return /* tuple */[
                              square,
                              piece
                            ];
                    }));
      }));

console.log(chess$1.ascii());

List.iter((function (param) {
        console.log(toString$2(param[0]), ":", toString$4(param[1]));
        return /* () */0;
      }), allPieces);

function play_random_game(t) {
  console.log("about to play random game");
  Random.self_init(/* () */0);
  var t$1 = t;
  while(true) {
    console.log(t$1.fen());
    console.log(t$1.ascii());
    if (t$1.game_over()) {
      console.log("Game over");
      return /* () */0;
    } else {
      var moves = legalMoves(/* None */0, t$1);
      var selected_move = Caml_array.caml_array_get(moves, Random.$$int(moves.length));
      console.log("selecting move:");
      console.log(toRaw$3(selected_move));
      var match = move(t$1, /* Full */Block.__(2, [selected_move]));
      if (match) {
        continue ;
        
      } else {
        console.log("error");
        return /* () */0;
      }
    }
  };
}

play_random_game(create(/* None */0, /* () */0));

var Color = [toString];

var Piece_000 = [toString$3];

var Piece = [
  Piece_000,
  toString$4
];

var Move_000 = [];

var Move_001 = [];

var Move = [
  Move_000,
  Move_001,
  Options
];

exports.Color = Color;
exports.File = File;
exports.Square = Square;
exports.Piece = Piece;
exports.create = create;
exports.ascii = ascii;
exports.fen = fen;
exports.gameOver = gameOver;
exports.get = get;
exports.Move = Move;
exports.legalMoves = legalMoves;
exports.move = move;
exports.loadPgn = loadPgn;
/* chess Not a pure module */
