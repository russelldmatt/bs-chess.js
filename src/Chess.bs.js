// Generated by BUCKLESCRIPT VERSION 2.2.3, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Random = require("bs-platform/lib/js/random.js");
var $$String = require("bs-platform/lib/js/string.js");
var ChessJs = require("chess.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Js_option = require("bs-platform/lib/js/js_option.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Js_primitive = require("bs-platform/lib/js/js_primitive.js");
var Caml_missing_polyfill = require("bs-platform/lib/js/caml_missing_polyfill.js");

function unimplemented(x) {
  console.log(x);
  return Js_exn.raiseError("Unimplemented");
}

var Raw = /* module */[];

function init(n, f) {
  return $$Array.to_list($$Array.init(n, f));
}

function bind(f, l) {
  return List.concat(List.map(f, l));
}

var List$1 = /* module */[
  /* length */List.length,
  /* hd */List.hd,
  /* tl */List.tl,
  /* nth */List.nth,
  /* rev */List.rev,
  /* append */List.append,
  /* rev_append */List.rev_append,
  /* concat */List.concat,
  /* flatten */List.flatten,
  /* iter */List.iter,
  /* iteri */List.iteri,
  /* map */List.map,
  /* mapi */List.mapi,
  /* rev_map */List.rev_map,
  /* fold_left */List.fold_left,
  /* fold_right */List.fold_right,
  /* iter2 */List.iter2,
  /* map2 */List.map2,
  /* rev_map2 */List.rev_map2,
  /* fold_left2 */List.fold_left2,
  /* fold_right2 */List.fold_right2,
  /* for_all */List.for_all,
  /* exists */List.exists,
  /* for_all2 */List.for_all2,
  /* exists2 */List.exists2,
  /* mem */List.mem,
  /* memq */List.memq,
  /* find */List.find,
  /* filter */List.filter,
  /* find_all */List.find_all,
  /* partition */List.partition,
  /* assoc */List.assoc,
  /* assq */List.assq,
  /* mem_assoc */List.mem_assoc,
  /* mem_assq */List.mem_assq,
  /* remove_assoc */List.remove_assoc,
  /* remove_assq */List.remove_assq,
  /* split */List.split,
  /* combine */List.combine,
  /* sort */List.sort,
  /* stable_sort */List.stable_sort,
  /* fast_sort */List.fast_sort,
  /* sort_uniq */List.sort_uniq,
  /* merge */List.merge,
  /* init */init,
  /* bind */bind,
  /* filter_map */Belt_List.keepMap
];

function ofRaw(raw) {
  switch (raw) {
    case "b" : 
        return /* Black */0;
    case "w" : 
        return /* White */1;
    default:
      return Js_exn.raiseError("Cannot convert color from raw (raw: " + (raw + ")"));
  }
}

function toString(t) {
  if (t !== 0) {
    return "white";
  } else {
    return "black";
  }
}

var Color = /* module */[
  /* ofRaw */ofRaw,
  /* toString */toString
];

function toString$1(t) {
  if (t >= 101) {
    if (t >= 103) {
      if (t >= 104) {
        return "h";
      } else {
        return "g";
      }
    } else if (t >= 102) {
      return "f";
    } else {
      return "e";
    }
  } else if (t >= 99) {
    if (t >= 100) {
      return "d";
    } else {
      return "c";
    }
  } else if (t >= 98) {
    return "b";
  } else {
    return "a";
  }
}

var all = /* :: */[
  /* a */97,
  /* :: */[
    /* b */98,
    /* :: */[
      /* c */99,
      /* :: */[
        /* d */100,
        /* :: */[
          /* e */101,
          /* :: */[
            /* f */102,
            /* :: */[
              /* g */103,
              /* :: */[
                /* h */104,
                /* [] */0
              ]
            ]
          ]
        ]
      ]
    ]
  ]
];

var File = /* module */[
  /* toString */toString$1,
  /* all */all
];

function toString$2(t) {
  return toString$1(t[/* file */0]) + String(t[/* rank */1]);
}

var Square = /* module */[/* toString */toString$2];

function ofRaw$1(raw) {
  var raw$1 = $$String.lowercase(raw);
  switch (raw$1) {
    case "b" : 
        return /* bishop */-262202819;
    case "k" : 
        return /* king */-955653801;
    case "n" : 
        return /* knight */-470198899;
    case "p" : 
        return /* pawn */-900601784;
    case "q" : 
        return /* queen */-571834454;
    case "r" : 
        return /* rook */-877728231;
    default:
      return Js_exn.raiseError("Cannot convert piece from raw (raw: " + (raw$1 + ")"));
  }
}

function toString$3(t) {
  if (t >= -877728231) {
    if (t >= -470198899) {
      if (t >= -262202819) {
        return "bishop";
      } else {
        return "knight";
      }
    } else if (t >= -571834454) {
      return "queen";
    } else {
      return "rook";
    }
  } else if (t >= -900601784) {
    return "pawn";
  } else {
    return "king";
  }
}

var Type = /* module */[
  /* ofRaw */ofRaw$1,
  /* toString */toString$3
];

function ofRaw$2(raw) {
  return /* record */[
          /* type_ */ofRaw$1(Js_option.getExn(Js_primitive.undefined_to_opt(raw["type"]))),
          /* color */ofRaw(Js_option.getExn(Js_primitive.undefined_to_opt(raw["color"])))
        ];
}

function toString$4(t) {
  return toString(t[/* color */1]) + (" " + toString$3(t[/* type_ */0]));
}

var Piece = /* module */[
  /* Type */Type,
  /* ofRaw */ofRaw$2,
  /* toString */toString$4
];

function create(fen, _) {
  var match = typeof (window) === "undefined" ? undefined : (window);
  if (match !== undefined) {
    return new ChessJs(fen ? fen[0] : undefined);
  } else {
    return new ChessJs.Chess(fen ? fen[0] : undefined);
  }
}

function ascii(prim) {
  return prim.ascii();
}

function fen(prim) {
  return prim.fen();
}

function gameOver(prim) {
  return +prim.game_over();
}

function get(t, square) {
  var rawSquare = toString$2(square);
  console.log("raw square: ", rawSquare);
  var raw = t.get(rawSquare);
  return Belt_Option.map((raw == null) ? /* None */0 : [raw], ofRaw$2);
}

var From_to = /* module */[/* toRaw */unimplemented];

var Full = /* module */[
  /* ofRaw */unimplemented,
  /* toRaw */unimplemented
];

var Options = /* module */[];

var Move = /* module */[
  /* From_to */From_to,
  /* Full */Full,
  /* Options */Options
];

function legalMoves(move_options, t) {
  var square = Belt_Option.flatMap(move_options, (function (x) {
          return x[/* square */0];
        }));
  var raw_full_moves = square ? t.moves({
          square: toString$2(square[0]),
          verbose: /* true */1
        }) : t.moves({
          verbose: /* true */1
        });
  return $$Array.map(unimplemented, raw_full_moves);
}

function move(t, req) {
  var parseResponse = function (r) {
    return Belt_Option.map((r == null) ? /* None */0 : [r], unimplemented);
  };
  switch (req.tag | 0) {
    case 0 : 
        return parseResponse(t.move(req[0]));
    case 1 : 
        return parseResponse(t.move(unimplemented(req[0])));
    case 2 : 
        return parseResponse(Caml_missing_polyfill.not_implemented("move not implemented by bucklescript yet\n"));
    
  }
}

var Api = /* module */[
  /* Color */Color,
  /* File */File,
  /* Square */Square,
  /* Piece */Piece,
  /* create */create,
  /* ascii */ascii,
  /* fen */fen,
  /* gameOver */gameOver,
  /* get */get,
  /* Move */Move,
  /* legalMoves */legalMoves,
  /* move */move
];

var chess = create(/* None */0, /* () */0);

console.log(chess.ascii());

console.log(chess.fen());

var chess$1 = create(/* Some */["r1k4r/p2nb1p1/2b4p/1p1n1p2/2PP4/3Q1NB1/1P3PPP/R5K1 b - c3 0 19"], /* () */0);

console.log(chess$1.ascii());

console.log("hey");

console.log(chess$1.ascii());

console.log(+chess$1.game_over());

console.log(get(chess$1, /* record */[
          /* file : e */101,
          /* rank */8
        ]));

console.log(get(chess$1, /* record */[
          /* file : e */101,
          /* rank */1
        ]));

console.log(Belt_Option.map(get(chess$1, /* record */[
              /* file : g */103,
              /* rank */2
            ]), toString$4));

var allRanks = $$Array.to_list($$Array.init(8, (function (x) {
            return x + 1 | 0;
          })));

var allSquares = List.concat(List.map((function (file) {
            return List.map((function (rank) {
                          return /* record */[
                                  /* file */file,
                                  /* rank */rank
                                ];
                        }), allRanks);
          }), all));

console.log("gettin all squares");

var allPieces = Belt_List.keepMap(allSquares, (function (square) {
        return Belt_Option.map(get(chess$1, square), (function (piece) {
                      return /* tuple */[
                              square,
                              piece
                            ];
                    }));
      }));

console.log(chess$1.ascii());

List.iter((function (param) {
        console.log(toString$2(param[0]), ":", toString$4(param[1]));
        return /* () */0;
      }), allPieces);

function play_random_game(t) {
  console.log("about to play random game");
  Random.self_init(/* () */0);
  var t$1 = t;
  while(true) {
    if (t$1.game_over()) {
      console.log("Game over");
      return /* () */0;
    } else {
      var moves = legalMoves(/* None */0, t$1);
      console.log("legal moves:");
      $$Array.iter((function (prim) {
              console.log(prim);
              return /* () */0;
            }), moves);
      var selected_move = Caml_array.caml_array_get(moves, Random.$$int(moves.length));
      var match = move(t$1, /* Full */Block.__(2, [selected_move]));
      if (match) {
        console.log(t$1.ascii());
        continue ;
        
      } else {
        console.log("error");
        return /* () */0;
      }
    }
  };
}

play_random_game(create(/* None */0, /* () */0));

var Tests = /* module */[
  /* chess */chess$1,
  /* allSquares */allSquares,
  /* allPieces */allPieces,
  /* play_random_game */play_random_game
];

exports.unimplemented = unimplemented;
exports.Raw = Raw;
exports.List = List$1;
exports.Api = Api;
exports.Color = Color;
exports.File = File;
exports.Square = Square;
exports.Piece = Piece;
exports.create = create;
exports.ascii = ascii;
exports.fen = fen;
exports.gameOver = gameOver;
exports.get = get;
exports.Move = Move;
exports.legalMoves = legalMoves;
exports.move = move;
exports.Tests = Tests;
/* chess Not a pure module */
