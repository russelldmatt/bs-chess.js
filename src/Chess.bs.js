// Generated by BUCKLESCRIPT VERSION 2.2.3, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var $$String = require("bs-platform/lib/js/string.js");
var Belt_Id = require("bs-platform/lib/js/belt_Id.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var ChessJs = require("chess.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Js_primitive = require("bs-platform/lib/js/js_primitive.js");
var Js_null_undefined = require("bs-platform/lib/js/js_null_undefined.js");

function ofBool(b) {
  if (b !== 0) {
    return /* success */944645571;
  } else {
    return /* fail */-1011500578;
  }
}

function ofRaw(raw) {
  switch (raw) {
    case "b" : 
        return /* Black */0;
    case "w" : 
        return /* White */1;
    default:
      return Js_exn.raiseError("Cannot convert color from raw (raw: " + (raw + ")"));
  }
}

function toRaw(t) {
  if (t !== 0) {
    return "w";
  } else {
    return "b";
  }
}

function toString(t) {
  if (t !== 0) {
    return "white";
  } else {
    return "black";
  }
}

function toChar(t) {
  if (t >= 101) {
    if (t >= 103) {
      if (t >= 104) {
        return /* "h" */104;
      } else {
        return /* "g" */103;
      }
    } else if (t >= 102) {
      return /* "f" */102;
    } else {
      return /* "e" */101;
    }
  } else if (t >= 99) {
    if (t >= 100) {
      return /* "d" */100;
    } else {
      return /* "c" */99;
    }
  } else if (t >= 98) {
    return /* "b" */98;
  } else {
    return /* "a" */97;
  }
}

function ofChar(c) {
  var switcher = c - 97 | 0;
  if (switcher > 7 || switcher < 0) {
    return Js_exn.raiseError("Cannot convert File.t from char (char: " + ($$String.make(1, c) + ")"));
  } else {
    return switcher + 97 | 0;
  }
}

function ofString(s) {
  return ofChar(Caml_string.get(s, 0));
}

function toString$1(t) {
  var c = toChar(t);
  return $$String.make(1, c);
}

var File_004 = /* all : :: */[
  /* a */97,
  /* :: */[
    /* b */98,
    /* :: */[
      /* c */99,
      /* :: */[
        /* d */100,
        /* :: */[
          /* e */101,
          /* :: */[
            /* f */102,
            /* :: */[
              /* g */103,
              /* :: */[
                /* h */104,
                /* [] */0
              ]
            ]
          ]
        ]
      ]
    ]
  ]
];

var File = /* module */[
  /* toChar */toChar,
  /* ofChar */ofChar,
  /* ofString */ofString,
  /* toString */toString$1,
  File_004
];

var all = $$Array.to_list($$Array.init(8, (function (x) {
            return x + 1 | 0;
          })));

var Rank = /* module */[/* all */all];

function toString$2(t) {
  var c = toChar(t[/* file */0]);
  return $$String.make(1, c) + String(t[/* rank */1]);
}

function ofString$1(s) {
  return /* record */[
          /* file */ofChar(Caml_string.get(s, 0)),
          /* rank */Caml_format.caml_int_of_string($$String.make(1, Caml_string.get(s, 1)))
        ];
}

var Square = /* module */[
  /* toString */toString$2,
  /* ofString */ofString$1
];

function ofRaw$1(raw) {
  var raw$1 = $$String.lowercase(raw);
  switch (raw$1) {
    case "b" : 
        return /* bishop */-262202819;
    case "k" : 
        return /* king */-955653801;
    case "n" : 
        return /* knight */-470198899;
    case "p" : 
        return /* pawn */-900601784;
    case "q" : 
        return /* queen */-571834454;
    case "r" : 
        return /* rook */-877728231;
    default:
      return Js_exn.raiseError("Cannot convert piece from raw (raw: " + (raw$1 + ")"));
  }
}

function toRaw$1(t) {
  if (t >= -877728231) {
    if (t >= -470198899) {
      if (t >= -262202819) {
        return "b";
      } else {
        return "n";
      }
    } else if (t >= -571834454) {
      return "q";
    } else {
      return "r";
    }
  } else if (t >= -900601784) {
    return "p";
  } else {
    return "k";
  }
}

function toString$3(t) {
  if (t >= -877728231) {
    if (t >= -470198899) {
      if (t >= -262202819) {
        return "bishop";
      } else {
        return "knight";
      }
    } else if (t >= -571834454) {
      return "queen";
    } else {
      return "rook";
    }
  } else if (t >= -900601784) {
    return "pawn";
  } else {
    return "king";
  }
}

function ofRaw$2(raw) {
  return /* record */[
          /* type_ */ofRaw$1(raw["type"]),
          /* color */ofRaw(raw.color)
        ];
}

function toRaw$2(t) {
  return {
          type: toRaw$1(t[/* type_ */0]),
          color: toRaw(t[/* color */1])
        };
}

function toString$4(t) {
  return toString(t[/* color */1]) + (" " + toString$3(t[/* type_ */0]));
}

function create(fen, _) {
  var match = typeof (window) === "undefined" ? undefined : (window);
  if (match !== undefined) {
    return new ChessJs(fen ? fen[0] : undefined);
  } else {
    return new ChessJs.Chess(fen ? fen[0] : undefined);
  }
}

function ascii(prim) {
  return prim.ascii();
}

function fen(prim) {
  return prim.fen();
}

function get(t, square) {
  var rawSquare = toString$2(square);
  var raw = t.get(rawSquare);
  return Belt_Option.map((raw == null) ? /* None */0 : [raw], ofRaw$2);
}

function toRaw$3(t) {
  return {
          from: t[/* from */0],
          to: t[/* to_ */1]
        };
}

function ofRaw$3(raw) {
  return /* record */[
          /* color */ofRaw(raw.color),
          /* from */ofString$1(raw.from),
          /* to_ */ofString$1(raw["to"]),
          /* flags */raw.flags,
          /* piece */ofRaw$1(raw.piece),
          /* san */raw.san
        ];
}

var Options = /* module */[];

function legalMoves(move_options, t) {
  var square = Belt_Option.flatMap(move_options, (function (x) {
          return x[/* square */0];
        }));
  var raw_full_moves = square ? t.moves({
          square: toString$2(square[0]),
          verbose: /* true */1
        }) : t.moves({
          verbose: /* true */1
        });
  return $$Array.map(ofRaw$3, raw_full_moves);
}

function move(t, req) {
  var parseResponse = function (r) {
    return Belt_Option.map((r == null) ? /* None */0 : [r], ofRaw$3);
  };
  switch (req.tag | 0) {
    case 0 : 
        return parseResponse(t.move(req[0]));
    case 1 : 
        return parseResponse(t.move(toRaw$3(req[0])));
    case 2 : 
        return parseResponse(t.move(req[0][/* san */5]));
    
  }
}

function loadPgn(sloppy, t, pgn) {
  var sloppy$1 = Js_null_undefined.fromOption(Belt_Option.map(sloppy, (function (s) {
              return {
                      sloppy: s
                    };
            })));
  return ofBool(+t.load_pgn(pgn, sloppy$1));
}

function hash(t) {
  return t;
}

var eq = Caml_obj.caml_equal;

var T = /* module */[
  /* hash */hash,
  /* eq */eq
];

Belt_Id.MakeHashable(T);

function inCheck(prim) {
  return +prim.in_check();
}

function gameOver(prim) {
  return +prim.game_over();
}

function inDraw(prim) {
  return +prim.in_draw();
}

function endState(t) {
  if (t.game_over()) {
    var match = +t.in_checkmate();
    var tmp;
    if (match !== 0) {
      tmp = /* Checkmate */0;
    } else {
      var match$1 = +t.in_stalemate();
      if (match$1 !== 0) {
        tmp = /* Stalemate */1;
      } else {
        var match$2 = +t.in_threefold_repetition();
        if (match$2 !== 0) {
          tmp = /* ThreefoldRepetition */2;
        } else {
          var match$3 = +t.insufficient_material();
          if (match$3 !== 0) {
            tmp = /* InsufficientMaterial */3;
          } else {
            var match$4 = +t.in_draw();
            if (match$4 !== 0) {
              tmp = /* FiftyMoveRule */4;
            } else {
              console.log(t.ascii());
              tmp = Js_exn.raiseError("game over but not sure why");
            }
          }
        }
      }
    }
    return /* Some */[tmp];
  } else {
    return /* None */0;
  }
}

function undo(t) {
  return Belt_Option.map(Js_primitive.null_undefined_to_opt(t.undo()), ofRaw$3);
}

function addToPgnHeader(t, key_value) {
  t.header(key_value[/* key */0], key_value[/* value */1]);
  return /* () */0;
}

function pgnHeader(prim) {
  return prim.header();
}

function pgn(prim) {
  return prim.pgn();
}

function turn(t) {
  return ofRaw(t.turn());
}

function remove(t, square) {
  return Belt_Option.map(Js_primitive.null_undefined_to_opt(t.remove(toString$2(square))), ofRaw$2);
}

function put(t, piece, square) {
  return ofBool(+t.put(toRaw$2(piece), toString$2(square)));
}

function validateFen(prim, prim$1) {
  return prim.validate_fen(prim$1);
}

function loadFen(t, fen) {
  var match = +t.load(fen);
  if (match !== 0) {
    return /* Ok */Block.__(0, [/* () */0]);
  } else {
    return /* Error */Block.__(1, [t.validate_fen(fen)]);
  }
}

function historySan(t) {
  return t.history();
}

function historyFull(t) {
  return $$Array.map(ofRaw$3, t.history({
                  verbose: /* true */1
                }));
}

function reset(prim) {
  prim.reset();
  return /* () */0;
}

var Color = [toString];

var Piece_000 = [toString$3];

var Piece = [
  Piece_000,
  toString$4
];

var EndState = [];

var Move_000 = [];

var Move_001 = [];

var Move = [
  Move_000,
  Move_001,
  Options
];

exports.create = create;
exports.validateFen = validateFen;
exports.loadFen = loadFen;
exports.fen = fen;
exports.loadPgn = loadPgn;
exports.pgn = pgn;
exports.pgnHeader = pgnHeader;
exports.addToPgnHeader = addToPgnHeader;
exports.ascii = ascii;
exports.Color = Color;
exports.File = File;
exports.Rank = Rank;
exports.Square = Square;
exports.Piece = Piece;
exports.EndState = EndState;
exports.endState = endState;
exports.inCheck = inCheck;
exports.gameOver = gameOver;
exports.inDraw = inDraw;
exports.get = get;
exports.Move = Move;
exports.legalMoves = legalMoves;
exports.move = move;
exports.undo = undo;
exports.remove = remove;
exports.put = put;
exports.turn = turn;
exports.historySan = historySan;
exports.historyFull = historyFull;
exports.reset = reset;
/* all Not a pure module */
